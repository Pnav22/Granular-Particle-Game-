<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Granular Particle Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            color: white;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            height: 100vh;
        }
        
        canvas {
            border: 2px solid #333;
            cursor: crosshair;
            background: #000;
        }
        
        #controls {
            width: 200px;
            background: #2a2a2a;
            padding: 20px;
            border-left: 2px solid #333;
            overflow-y: auto;
        }
        
        .material-btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: 2px solid #444;
            background: #333;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .material-btn:hover {
            background: #444;
            border-color: #666;
        }
        
        .material-btn.active {
            background: #555;
            border-color: #888;
            box-shadow: 0 0 10px rgba(255,255,255,0.2);
        }
        
        .controls-section {
            margin: 20px 0;
        }
        
        .controls-section h3 {
            margin: 0 0 10px 0;
            color: #ccc;
            font-size: 14px;
            text-transform: uppercase;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        label {
            display: block;
            margin: 5px 0;
            font-size: 12px;
        }
        
        #clearBtn {
            background: #d44;
            border-color: #d44;
        }
        
        #clearBtn:hover {
            background: #e55;
        }
        
        .info {
            font-size: 11px;
            color: #888;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas" width="800" height="600"></canvas>
        <div id="controls">
            <div class="controls-section">
                <h3>Materials</h3>
                <button class="material-btn active" data-material="sand">üèñÔ∏è Sand</button>
                <button class="material-btn" data-material="water">üíß Water</button>
                <button class="material-btn" data-material="stone">üóø Stone</button>
                <button class="material-btn" data-material="fire">üî• Fire</button>
                <button class="material-btn" data-material="smoke">üí® Smoke</button>
                <button class="material-btn" data-material="oil">üõ¢Ô∏è Oil</button>
                <button class="material-btn" data-material="acid">üß™ Acid</button>
                <button class="material-btn" data-material="plant">üå± Plant</button>
            </div>
            
            <div class="controls-section">
                <h3>Brush</h3>
                <label>Size: <span id="brushSizeDisplay">5</span></label>
                <input type="range" id="brushSize" min="1" max="20" value="5">
            </div>
            
            <div class="controls-section">
                <h3>Controls</h3>
                <button id="clearBtn" class="material-btn">Clear All</button>
                <button id="pauseBtn" class="material-btn">Pause</button>
            </div>
            
            <div class="info">
                <p>Click and drag to place materials</p>
                <p>Different materials have unique physics properties</p>
                <p>Watch them interact!</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const CELL_SIZE = 2;
        const GRID_WIDTH = Math.floor(canvas.width / CELL_SIZE);
        const GRID_HEIGHT = Math.floor(canvas.height / CELL_SIZE);
        
        let grid = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
        let velocityX = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
        let velocityY = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
        let temperature = new Array(GRID_WIDTH * GRID_HEIGHT).fill(20);
        let life = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
        
        let currentMaterial = 1; // sand
        let brushSize = 5;
        let isDrawing = false;
        let isPaused = false;
        
        const materials = {
            0: { name: 'empty', color: [0, 0, 0], density: 0, flammable: false, burns: false, liquid: false },
            1: { name: 'sand', color: [238, 203, 173], density: 3, flammable: false, burns: false, liquid: false },
            2: { name: 'water', color: [64, 164, 223], density: 2, flammable: false, burns: false, liquid: true },
            3: { name: 'stone', color: [128, 128, 128], density: 5, flammable: false, burns: false, liquid: false },
            4: { name: 'fire', color: [255, 100, 0], density: 0, flammable: false, burns: true, liquid: false },
            5: { name: 'smoke', color: [100, 100, 100], density: 0, flammable: false, burns: false, liquid: false },
            6: { name: 'oil', color: [139, 69, 19], density: 1, flammable: true, burns: false, liquid: true },
            7: { name: 'acid', color: [50, 255, 50], density: 2, flammable: false, burns: false, liquid: true },
            8: { name: 'plant', color: [34, 139, 34], density: 2, flammable: true, burns: false, liquid: false }
        };
        
        function getIndex(x, y) {
            return y * GRID_WIDTH + x;
        }
        
        function isValid(x, y) {
            return x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT;
        }
        
        function getCell(x, y) {
            if (!isValid(x, y)) return 3; // stone boundary
            return grid[getIndex(x, y)];
        }
        
        function setCell(x, y, material) {
            if (!isValid(x, y)) return;
            grid[getIndex(x, y)] = material;
        }
        
        function swapCells(x1, y1, x2, y2) {
            if (!isValid(x1, y1) || !isValid(x2, y2)) return;
            const idx1 = getIndex(x1, y1);
            const idx2 = getIndex(x2, y2);
            
            [grid[idx1], grid[idx2]] = [grid[idx2], grid[idx1]];
            [velocityX[idx1], velocityX[idx2]] = [velocityX[idx2], velocityX[idx1]];
            [velocityY[idx1], velocityY[idx2]] = [velocityY[idx2], velocityY[idx1]];
            [temperature[idx1], temperature[idx2]] = [temperature[idx2], temperature[idx1]];
            [life[idx1], life[idx2]] = [life[idx2], life[idx1]];
        }
        
        function placeMaterial(x, y, material) {
            const centerX = Math.floor(x / CELL_SIZE);
            const centerY = Math.floor(y / CELL_SIZE);
            
            for (let dx = -brushSize; dx <= brushSize; dx++) {
                for (let dy = -brushSize; dy <= brushSize; dy++) {
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= brushSize) {
                        const nx = centerX + dx;
                        const ny = centerY + dy;
                        if (isValid(nx, ny) && Math.random() < 0.7) {
                            setCell(nx, ny, material);
                            if (material === 4) { // fire
                                temperature[getIndex(nx, ny)] = 1000;
                                life[getIndex(nx, ny)] = 60 + Math.random() * 120;
                            }
                        }
                    }
                }
            }
        }
        
        function updatePhysics() {
            if (isPaused) return;
            
            const newGrid = [...grid];
            const newVelocityX = [...velocityX];
            const newVelocityY = [...velocityY];
            const newTemperature = [...temperature];
            const newLife = [...life];
            
            // Process each cell
            for (let y = GRID_HEIGHT - 2; y >= 0; y--) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const idx = getIndex(x, y);
                    const material = grid[idx];
                    const mat = materials[material];
                    
                    if (material === 0) continue;
                    
                    // Fire behavior
                    if (material === 4) {
                        newLife[idx]--;
                        if (newLife[idx] <= 0) {
                            newGrid[idx] = Math.random() < 0.3 ? 5 : 0; // become smoke or disappear
                            continue;
                        }
                        
                        // Spread fire
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                const nx = x + dx, ny = y + dy;
                                if (isValid(nx, ny)) {
                                    const nidx = getIndex(nx, ny);
                                    const nmaterial = grid[nidx];
                                    if (materials[nmaterial].flammable && Math.random() < 0.02) {
                                        newGrid[nidx] = 4;
                                        newLife[nidx] = 60 + Math.random() * 60;
                                        newTemperature[nidx] = 800;
                                    }
                                }
                            }
                        }
                        
                        // Move upward with random direction
                        if (Math.random() < 0.8) {
                            const moveY = y - 1;
                            const moveX = x + (Math.random() - 0.5 > 0 ? 1 : -1) * Math.floor(Math.random() * 2);
                            if (isValid(moveX, moveY) && grid[getIndex(moveX, moveY)] === 0) {
                                newGrid[getIndex(moveX, moveY)] = 4;
                                newLife[getIndex(moveX, moveY)] = newLife[idx];
                                newGrid[idx] = 0;
                            }
                        }
                        continue;
                    }
                    
                    // Smoke behavior
                    if (material === 5) {
                        newLife[idx]++;
                        if (newLife[idx] > 200) {
                            newGrid[idx] = 0;
                            continue;
                        }
                        
                        // Move upward
                        if (Math.random() < 0.9) {
                            const moveY = y - 1;
                            const moveX = x + (Math.random() - 0.5 > 0 ? 1 : -1) * Math.floor(Math.random() * 2);
                            if (isValid(moveX, moveY) && (grid[getIndex(moveX, moveY)] === 0 || materials[grid[getIndex(moveX, moveY)]].density < mat.density)) {
                                swapCells(x, y, moveX, moveY);
                            }
                        }
                        continue;
                    }
                    
                    // Acid behavior
                    if (material === 7) {
                        // Dissolve adjacent materials
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                const nx = x + dx, ny = y + dy;
                                if (isValid(nx, ny) && Math.random() < 0.001) {
                                    const nmaterial = grid[getIndex(nx, ny)];
                                    if (nmaterial !== 0 && nmaterial !== 3 && nmaterial !== 7) {
                                        newGrid[getIndex(nx, ny)] = 0;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Plant growth
                    if (material === 8) {
                        if (Math.random() < 0.001) {
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dy = -1; dy <= 1; dy++) {
                                    const nx = x + dx, ny = y + dy;
                                    if (isValid(nx, ny) && grid[getIndex(nx, ny)] === 0 && Math.random() < 0.3) {
                                        newGrid[getIndex(nx, ny)] = 8;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Gravity and liquid flow
                    if (mat.density > 0) {
                        let moved = false;
                        
                        // Try to fall down
                        if (y < GRID_HEIGHT - 1) {
                            const below = getCell(x, y + 1);
                            if (below === 0 || (materials[below].density < mat.density && below !== material)) {
                                swapCells(x, y, x, y + 1);
                                moved = true;
                                newVelocityY[getIndex(x, y + 1)] = Math.min(newVelocityY[getIndex(x, y + 1)] + 0.1, 2);
                            }
                        }
                        
                        // Liquid flow
                        if (!moved && mat.liquid) {
                            const directions = Math.random() < 0.5 ? [-1, 1] : [1, -1];
                            
                            for (const dir of directions) {
                                const sideX = x + dir;
                                if (isValid(sideX, y)) {
                                    const side = getCell(sideX, y);
                                    if (side === 0 || (materials[side].density < mat.density && materials[side].liquid)) {
                                        swapCells(x, y, sideX, y);
                                        moved = true;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // Powder dispersion
                        if (!moved && !mat.liquid && Math.random() < 0.3) {
                            const directions = Math.random() < 0.5 ? [-1, 1] : [1, -1];
                            
                            for (const dir of directions) {
                                const diagX = x + dir;
                                const diagY = y + 1;
                                if (isValid(diagX, diagY)) {
                                    const diag = getCell(diagX, diagY);
                                    if (diag === 0 || (materials[diag].density < mat.density && diag !== material)) {
                                        swapCells(x, y, diagX, diagY);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            grid = newGrid;
            velocityX = newVelocityX;
            velocityY = newVelocityY;
            temperature = newTemperature;
            life = newLife;
        }
        
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const material = grid[getIndex(x, y)];
                    const mat = materials[material];
                    
                    if (material !== 0) {
                        let color = [...mat.color];
                        
                        // Add some variation
                        if (material === 4) { // fire
                            const intensity = life[getIndex(x, y)] / 120;
                            color = [
                                255,
                                Math.floor(100 + 155 * intensity),
                                Math.floor(50 * intensity)
                            ];
                        } else if (material === 5) { // smoke
                            const fade = Math.max(0, 1 - life[getIndex(x, y)] / 200);
                            color = color.map(c => Math.floor(c * fade));
                        } else {
                            color = color.map(c => c + (Math.random() - 0.5) * 20);
                        }
                        
                        // Draw the cell
                        for (let dx = 0; dx < CELL_SIZE; dx++) {
                            for (let dy = 0; dy < CELL_SIZE; dy++) {
                                const pixelX = x * CELL_SIZE + dx;
                                const pixelY = y * CELL_SIZE + dy;
                                const pixelIndex = (pixelY * canvas.width + pixelX) * 4;
                                
                                if (pixelIndex < data.length) {
                                    data[pixelIndex] = Math.max(0, Math.min(255, color[0]));
                                    data[pixelIndex + 1] = Math.max(0, Math.min(255, color[1]));
                                    data[pixelIndex + 2] = Math.max(0, Math.min(255, color[2]));
                                    data[pixelIndex + 3] = 255;
                                }
                            }
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        function gameLoop() {
            updatePhysics();
            render();
            requestAnimationFrame(gameLoop);
        }
        
        // Event listeners
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            placeMaterial(e.clientX - rect.left, e.clientY - rect.top, currentMaterial);
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                const rect = canvas.getBoundingClientRect();
                placeMaterial(e.clientX - rect.left, e.clientY - rect.top, currentMaterial);
            }
        });
        
        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => isDrawing = false);
        
        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            placeMaterial(touch.clientX - rect.left, touch.clientY - rect.top, currentMaterial);
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDrawing) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                placeMaterial(touch.clientX - rect.left, touch.clientY - rect.top, currentMaterial);
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDrawing = false;
        });
        
        // Material selection
        document.querySelectorAll('.material-btn[data-material]').forEach((btn, index) => {
            btn.addEventListener('click', () => {
                document.querySelector('.material-btn.active').classList.remove('active');
                btn.classList.add('active');
                currentMaterial = index + 1;
            });
        });
        
        // Brush size
        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushSizeDisplay').textContent = brushSize;
        });
        
        // Clear button
        document.getElementById('clearBtn').addEventListener('click', () => {
            grid.fill(0);
            velocityX.fill(0);
            velocityY.fill(0);
            temperature.fill(20);
            life.fill(0);
        });
        
        // Pause button
        document.getElementById('pauseBtn').addEventListener('click', () => {
            isPaused = !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? 'Resume' : 'Pause';
        });
        
        // Start the simulation
        gameLoop();
    </script>
</body>
</html>